export module engine.match;

import std;
import stormkit.core;
import geometry;

import grid;
import potentials;
import engine.rewriterule;

namespace stk  = stormkit;

export
struct Match {
  std::span<const RewriteRule> rules;
  Area3::Offset u;
  stk::ioffset  r;

  double w = 1.0;

  auto area() const noexcept -> Area3 {
    return rules[r].output.area() + u;
  }

  static auto scan(
    const Grid<char>& grid,
    std::span<const RewriteRule> rules,
    std::span<const Change<char>> history = {}
  ) noexcept -> std::vector<Match>;

  auto match(const Grid<char>& grid) const noexcept -> bool;
  auto conflict(const Match& other) const noexcept -> bool;
  auto changes(const Grid<char>& grid) const noexcept -> std::vector<Change<char>>;

  auto delta(const Grid<char>& grid, const Potentials& potentials) const noexcept -> double;

  auto backward_match(const Potentials& potentials, double p) const noexcept -> bool;
  auto backward_changes(const Potentials& potentials) const noexcept
  -> std::vector<Change<char>>;

  auto forward_match(const Potentials& potentials, double p) const noexcept -> bool;
  auto forward_changes(const Potentials& potentials, double p) const noexcept
  -> std::vector<Change<std::tuple<char, double>>>;
};

export template <>
struct std::formatter<Match> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Match& m, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("{}:{}", m.u, m.r);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
