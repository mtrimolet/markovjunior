export module engine.match;

import std;
import stormkit.core;
import geometry;

import grid;
import potentials;
import engine.rewriterule;

namespace stk  = stormkit;

export {
struct Match {
  std::span<const RewriteRule> rules;
  Area3::Offset u;
  stk::ioffset  r;

  double w = 1.0;

  auto area() const noexcept -> Area3 {
    return rules[r].output.area() + u;
  }

  static auto scan(
    const Grid<char>& grid,
    std::span<const RewriteRule> rules,
    std::span<const Change<char>> history = {}
  ) noexcept -> std::vector<Match>;

  auto match(const Grid<char>& grid) const noexcept -> bool;
  auto conflict(const Match& other) const noexcept -> bool;
  auto changes(const Grid<char>& grid) const noexcept -> std::vector<Change<char>>;

  auto delta(const Grid<char>& grid, const Potentials& potentials) const noexcept -> double;

  auto backward_match(const Potentials& potentials, double p) const noexcept -> bool;
  auto backward_changes(const Potentials& potentials) const noexcept
  -> std::vector<Change<char>>;

  auto forward_match(const Potentials& potentials, double p) const noexcept -> bool;
  auto forward_changes(const Potentials& potentials) const noexcept
  -> std::vector<Change<char>>;
};

template <class CharT>
struct std::formatter<Match, CharT> : std::formatter<std::basic_string<CharT>, CharT> {
  template<class FmtContext>
  auto format(const Match& data, FmtContext& ctx) const -> decltype(ctx.out()) {
    return std::format_to(ctx.out(), "[(Match) u = {}, r = {}]", data.u, data.r);
  }
};

}
