export module engine.rewriterule;

import std;
import geometry;

import grid;

export {

using charset = std::unordered_set<char>;

struct RewriteRule {
  using Input  = std::optional<charset>;
  using Output = std::optional<char>;
  using Unions = std::unordered_map<char, charset>;
  using Shifts = std::unordered_multimap<char, Area3::Offset>;
  using Dist   = std::bernoulli_distribution;
  
  static constexpr auto IGNORED_SYMBOL = char { '*' };
  
  Grid<Input>  input;
  Grid<Output> output;

  Dist draw;
  bool is_copy;

  static auto parse(
    const Unions& unions,
    std::string_view input,
    std::string_view output,
    double p = 1.0
  ) noexcept -> RewriteRule;

  RewriteRule() = delete;
  RewriteRule(Grid<Input>&& input, Grid<Output>&& output, double p = 1.0, bool is_copy = false) noexcept;

  RewriteRule(RewriteRule&&) noexcept = default;
  auto operator=(RewriteRule&&) noexcept -> RewriteRule& = default;
  RewriteRule(const RewriteRule&) noexcept = delete;
  auto operator=(const RewriteRule&) noexcept -> RewriteRule& = delete;

  auto operator==(const RewriteRule& other) const noexcept -> bool;

  /** Provides the relative area from inside which this rule would update the origin */
  auto backward_neighborhood() const noexcept -> Area3;
  auto get_ishifts(char c) const noexcept -> std::vector<Area3::Offset>;
  auto get_oshifts(char c) const noexcept -> std::vector<Area3::Offset>;

  auto identity() const noexcept -> RewriteRule;
  auto xreflected() const noexcept -> RewriteRule;
  auto xyrotated() const noexcept -> RewriteRule;
  auto zyrotated() const noexcept -> RewriteRule;

private:
  Shifts ishifts, oshifts;

};

template <class CharT>
struct std::formatter<RewriteRule, CharT> : std::formatter<std::basic_string<CharT>, CharT> {
  std::basic_string<CharT> sep = "→";
  template<class FmtContext>
  auto format(const RewriteRule& data, FmtContext& ctx) const -> decltype(ctx.out()) {
    return std::format_to(ctx.out(), "[(RewriteRule) extents = {}, input = {} {} output = {}]", data.input.extents, data.input, sep, data.output);
  }
};

}
