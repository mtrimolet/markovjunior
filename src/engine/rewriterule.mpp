export module engine.rewriterule;

import std;
import stormkit.core;
import geometry;

import grid;

// namespace stk = stormkit;

export 
struct RewriteRule {
  using Input  = std::optional<std::set<char>>;
  using Output = std::optional<char>;
  using Unions = std::unordered_map<char, std::set<char>>;
  using Shifts = std::unordered_multimap<char, Area3::Offset>;
  using Dist   = std::bernoulli_distribution;
  
  static constexpr auto IGNORED_SYMBOL = char { '*' };
  
  Grid<Input>  input;
  Grid<Output> output;

  Dist draw;
  bool is_copy;

  static auto parse(
    const Unions& unions,
    std::string_view input,
    std::string_view output,
    double p = 1.0
  ) noexcept -> RewriteRule;

  RewriteRule() = delete;
  RewriteRule(Grid<Input>&& input, Grid<Output>&& output, double p = 1.0, bool is_copy = false) noexcept;

  RewriteRule(RewriteRule&&) noexcept = default;
  auto operator=(RewriteRule&&) noexcept -> RewriteRule& = default;
  RewriteRule(const RewriteRule&) noexcept = delete;
  auto operator=(const RewriteRule&) noexcept -> RewriteRule& = delete;

  auto operator==(const RewriteRule& other) const noexcept -> bool;

  /** Provides the relative area from inside which this rule would update the origin */
  auto backward_neighborhood() const noexcept -> Area3;
  auto get_ishifts(char c) const noexcept -> std::vector<Area3::Offset>;

  auto identity() const noexcept -> RewriteRule;
  auto xreflected() const noexcept -> RewriteRule;
  auto xyrotated() const noexcept -> RewriteRule;
  auto zyrotated() const noexcept -> RewriteRule;

private:
  Shifts ishifts, oshifts;

};

export template <>
struct std::formatter<RewriteRule> {
  std::string sep = "â†’";
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const RewriteRule& r, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("[{}x{}]{}{}{}", r.input.extents.extent(2), r.input.extents.extent(1), r.input, sep, r.output);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
