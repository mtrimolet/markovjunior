export module geometry;

import std;
import stormkit.core;
export import glm;

namespace stk = stormkit;

export {

namespace geometry {

// glm only provides geometry functions for vectors of floating-point number types

template <stk::meta::IsArithmetic T>
constexpr auto dot(const glm::vec<3, T>& a, const glm::vec<3, T>& b) noexcept -> decltype(auto) {
  // this will silently overflow
  return a.x * b.x
       + a.y * b.y
       + a.z * b.z;
}

}

template <stk::usize E>
using Offset = glm::vec<E, stk::ioffset>;
template <stk::usize E>
using Size = glm::vec<E, stk::usize>;

template <stk::usize E>
struct Area {
  using Offset = Offset<E>;
  using Size = Size<E>;

  Offset u;
  Size size;

  constexpr bool operator==(const Area& other) const noexcept = default;

  constexpr auto shiftmax() const noexcept -> Offset {
    return size - (size / size);
  }

  constexpr auto outerbound() const noexcept -> Offset {
    return u + static_cast<Offset>(size);
  }

  constexpr auto contains(const Offset& v) const noexcept -> bool {
    return glm::all(glm::lessThanEqual(u, v))
       and glm::all(glm::lessThan(v, outerbound()));
  }

  constexpr auto operator+(const Offset& shift) const noexcept -> Area {
    return {u + shift, size};
  }

  constexpr auto operator-(const Offset& shift) const noexcept -> Area {
    return {u - shift, size};
  }

  constexpr auto operator*(stk::usize r) const noexcept -> Area {
    return {u, size * r};
  }

  constexpr auto operator/(stk::usize r) const noexcept -> Area {
    return {u, size / r};
  }

  constexpr auto center() const noexcept -> decltype(auto) {
    return operator/(2u).outerbound();
  }

  constexpr auto overlaps(const Area& other) const noexcept -> bool {
    return glm::all(glm::lessThan(      u, other.outerbound()))
       and glm::all(glm::lessThan(other.u,       outerbound()));
  }

  constexpr auto meet(const Area& other) const noexcept -> Area {
    if (not overlaps(other)) return {};
    auto&& u    = max(this->u, other.u);
    auto&& size = min(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }

  constexpr auto join(const Area& other) const noexcept -> Area {
    auto&& u    = min(this->u, other.u);
    auto&& size = max(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }
};

using Area3 = Area<3>;

constexpr auto xreflected(const Area3& a) noexcept -> Area3 {
  /* u -> { size.x - u.x - 1u, u.y, u.z } */
  return {a.u, a.size};
}

constexpr auto xyrotated(const Area3& a) noexcept -> Area3 {
  /* u -> { u.y, size.x - u.x - 1, u.z } */
  return {a.u, {
    a.size.y,
    a.size.x,
    a.size.z
  }};
}

constexpr auto zyrotated(const Area3& a) noexcept -> Area3 {
  /* u -> { u.x, size.z - u.z - 1, u.y } */
  return {a.u, {
    a.size.x,
    a.size.z,
    a.size.y
  }};
}

template <stk::meta::IsArithmetic T, class CharT>
struct std::formatter<glm::vec<3, T>, CharT> : std::formatter<std::basic_string<CharT>, CharT> {
  template<class FmtContext>
  auto format(const glm::vec<3, T>& data, FmtContext& ctx) const -> decltype(ctx.out()) {
    return std::format_to(ctx.out(), "[(glm::vec<{}>) x = {}, y = {}, z = {}]", 3, data.x, data.y, data.z);
  }
};

template <stk::usize E, class CharT>
struct std::formatter<Area<E>, CharT> : std::formatter<std::basic_string<CharT>, CharT> {
  template<class FmtContext>
  auto format(const Area<E>& data, FmtContext& ctx) const -> decltype(ctx.out()) {
    return std::format_to(ctx.out(), "[(Area<{}>) u = {}, size = {}]", E, data.u, data.size);
  }
};

template <stk::meta::IsArithmetic T>
struct std::hash<glm::vec<3, T>> {
  constexpr auto operator()(glm::vec<3, T> u) const noexcept -> std::size_t {
    auto h = std::hash<T>{};
    return h(u.x)
         ^ h(u.y)
         ^ h(u.z);
  }
};

}
