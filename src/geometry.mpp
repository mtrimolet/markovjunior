export module geometry;

import std;
import glm;
import stormkit.core;

namespace stk = stormkit;

export {

using glm::operator+;
using glm::operator-;
using glm::operator*;
using glm::operator/;
using glm::operator%;
using glm::operator==;
using glm::operator!=;

template <stk::usize E, stk::meta::IsArithmetic T>
struct std::formatter<glm::vec<E, T>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for glm::vec.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const glm::vec<E, T>& m, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << "[";
      for (auto i = 0; i < E; i++) {
        out << std::format("{}", std::get<i>(m));
        if (i < E - 1) out << " ";
      }
      out << "]";

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};

namespace geometry {

// glm only provides geometry functions for vectors of floating-point number types

template <stk::meta::IsArithmetic T>
inline constexpr auto dot(const glm::vec<3, T>& a, const glm::vec<3, T>& b) noexcept -> decltype(auto) {
  // this will silently overflow
  return a.x * b.x
       + a.y * b.y
       + a.z * b.z;
}

}

template <>
struct std::hash<glm::vec<3, stk::u32>> {
  inline constexpr auto operator()(glm::vec<3, stk::u32> u) const noexcept -> std::size_t {
    auto h = std::hash<stk::u32>{};
    return h(u.x)
         ^ h(u.y)
         ^ h(u.z);
  }
};

template <stk::usize E, stk::meta::IsArithmetic T>
struct HyperRectangle {
  using Position = glm::vec<E, T>;
  using Size = glm::vec<E, std::make_unsigned_t<T>>;

  Position u;
  Size size;

  inline constexpr HyperRectangle() noexcept = default;

  inline constexpr HyperRectangle(Position _u, Size _size) noexcept
    : u{_u}, size{_size} {}

  template <stk::meta::IsArithmetic T2>
  inline constexpr HyperRectangle(const HyperRectangle<E, T2>& other) noexcept
    : HyperRectangle{other.u, other.size} {}

  inline constexpr auto shiftmax() const noexcept -> Position {
    return size - (size / size);
  }

  inline constexpr auto outerbound() const noexcept -> Position {
    return u + static_cast<Position>(size);
  }

  inline constexpr auto contains(const Position& v) const noexcept -> bool {
    return glm::all(glm::lessThanEqual(u, v))
       and glm::all(glm::lessThan(v, outerbound()));
  }

  inline constexpr auto operator+(const HyperRectangle& other) const noexcept -> HyperRectangle {
    return {u + other.u, size + other.size};
  }

  inline constexpr auto operator-(const HyperRectangle& other) const noexcept -> HyperRectangle {
    return {u - other.u, size - other.size};
  }

  inline constexpr auto operator+(const Position& shift) const noexcept -> HyperRectangle {
    return {u + shift, size};
  }

  inline constexpr auto operator-(const Position& shift) const noexcept -> HyperRectangle {
    return {u - shift, size};
  }

  inline constexpr auto operator*(T r) const noexcept -> HyperRectangle {
    if constexpr (std::is_same_v<Position, Size>)
      return {u * r, size * r};
    else
      return {u * r, size * std::abs(r)};
  }

  inline constexpr auto operator/(T r) const noexcept -> HyperRectangle {
    if constexpr (std::is_same_v<Position, Size>)
      return {u / r, size / r};
    else
      return {u / r, size / std::abs(r)};
  }

  inline constexpr auto center() const noexcept -> decltype(auto) {
    return operator/(2u).outerbound();
  }

  inline constexpr auto overlaps(const HyperRectangle& other) const noexcept -> bool {
    return glm::all(glm::lessThan(      u, other.outerbound()))
       and glm::all(glm::lessThan(other.u,       outerbound()));
  }

  inline constexpr auto meet(const HyperRectangle& other) const noexcept -> HyperRectangle {
    if (not overlaps(other)) return {};
    auto&& u    = max(this->u, other.u);
    auto&& size = min(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }

  inline constexpr auto umeet(const HyperRectangle<E, std::make_unsigned_t<T>>& other) const noexcept -> HyperRectangle<E, std::make_unsigned_t<T>> 
  requires (not std::is_same_v<Position, Size>) {
    return meet(other);
  }

  inline constexpr auto join(const HyperRectangle& other) const noexcept -> HyperRectangle {
    auto&& u    = min(this->u, other.u);
    auto&& size = max(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }
};

using Area3U = HyperRectangle<3, stk::u32>;
using Area3I = HyperRectangle<3, stk::i32>;

inline constexpr auto xreflected(const Area3U& a) noexcept -> Area3U {
  /* u -> { size.x - u.x - 1u, u.y, u.z } */
  return {a.u, a.size};
}

inline constexpr auto xyrotated(const Area3U& a) noexcept -> Area3U {
  /* u -> { u.y, size.x - u.x - 1, u.z } */
  return {a.u, {
    a.size.y,
    a.size.x,
    a.size.z
  }};
}

inline constexpr auto zyrotated(const Area3U& a) noexcept -> Area3U {
  /* u -> { u.x, size.z - u.z - 1, u.y } */
  return {a.u, {
    a.size.x,
    a.size.z,
    a.size.y
  }};
}

template <stk::usize E, class T>
struct std::formatter<HyperRectangle<E, T>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for Grid.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const HyperRectangle<E, T>& r, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("box[u = {}, size = {}] ", r.u, r.size);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};

}
