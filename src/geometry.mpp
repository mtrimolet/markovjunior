export module geometry;

import std;
import stormkit.core;
export import glm;

namespace stk = stormkit;

export {

template <stk::meta::IsArithmetic T>
struct std::formatter<glm::vec<3, T>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for glm::vec.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const glm::vec<3, T>& m, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("[{}, {}, {}]", m.x, m.y, m.z);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};

namespace geometry {

// glm only provides geometry functions for vectors of floating-point number types

template <stk::meta::IsArithmetic T>
constexpr auto dot(const glm::vec<3, T>& a, const glm::vec<3, T>& b) noexcept -> decltype(auto) {
  // this will silently overflow
  return a.x * b.x
       + a.y * b.y
       + a.z * b.z;
}

}

template <stk::meta::IsArithmetic T>
struct std::hash<glm::vec<3, T>> {
  constexpr auto operator()(glm::vec<3, T> u) const noexcept -> std::size_t {
    auto h = std::hash<T>{};
    return h(u.x)
         ^ h(u.y)
         ^ h(u.z);
  }
};

template <stk::usize E>
using Offset = glm::vec<E, stk::ioffset>;
template <stk::usize E>
using Size = glm::vec<E, stk::usize>;

template <stk::usize E>
struct Area {
  using Offset = Offset<E>;
  using Size = Size<E>;

  Offset u;
  Size size;

  constexpr bool operator==(const Area& other) const noexcept = default;

  constexpr auto shiftmax() const noexcept -> Offset {
    return size - (size / size);
  }

  constexpr auto outerbound() const noexcept -> Offset {
    return u + static_cast<Offset>(size);
  }

  constexpr auto contains(const Offset& v) const noexcept -> bool {
    return glm::all(glm::lessThanEqual(u, v))
       and glm::all(glm::lessThan(v, outerbound()));
  }

  constexpr auto operator+(const Offset& shift) const noexcept -> Area {
    return {u + shift, size};
  }

  constexpr auto operator-(const Offset& shift) const noexcept -> Area {
    return {u - shift, size};
  }

  constexpr auto operator*(stk::usize r) const noexcept -> Area {
    return {u, size * r};
  }

  constexpr auto operator/(stk::usize r) const noexcept -> Area {
    return {u, size / r};
  }

  constexpr auto center() const noexcept -> decltype(auto) {
    return operator/(2u).outerbound();
  }

  constexpr auto overlaps(const Area& other) const noexcept -> bool {
    return glm::all(glm::lessThan(      u, other.outerbound()))
       and glm::all(glm::lessThan(other.u,       outerbound()));
  }

  constexpr auto meet(const Area& other) const noexcept -> Area {
    if (not overlaps(other)) return {};
    auto&& u    = max(this->u, other.u);
    auto&& size = min(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }

  constexpr auto join(const Area& other) const noexcept -> Area {
    auto&& u    = min(this->u, other.u);
    auto&& size = max(outerbound(), other.outerbound()) - u;
    return {std::move(u), std::move(size)};
  }
};

using Area3 = Area<3>;

constexpr auto xreflected(const Area3& a) noexcept -> Area3 {
  /* u -> { size.x - u.x - 1u, u.y, u.z } */
  return {a.u, a.size};
}

constexpr auto xyrotated(const Area3& a) noexcept -> Area3 {
  /* u -> { u.y, size.x - u.x - 1, u.z } */
  return {a.u, {
    a.size.y,
    a.size.x,
    a.size.z
  }};
}

constexpr auto zyrotated(const Area3& a) noexcept -> Area3 {
  /* u -> { u.x, size.z - u.z - 1, u.y } */
  return {a.u, {
    a.size.x,
    a.size.z,
    a.size.y
  }};
}

template <stk::usize E>
struct std::formatter<Area<E>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for Grid.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Area<E>& r, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("box[u = {}, size = {}] ", r.u, r.size);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};

}
