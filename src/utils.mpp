export module utils;

import std;
import ranges;
import stormkit.core;

namespace stk = stormkit;
namespace stdr = std::ranges;
namespace stdv = std::views;

export {

template <class R, class T>
concept container_compatible_range = 
  stdr::input_range<R>
  and std::convertible_to<stdr::range_reference_t<R>, T>;

template <class... T>
struct Visitor : T... { using T::operator()...; };

// from: https://stackoverflow.com/a/13370695
template <typename ReturnType, typename... Args>
std::function<ReturnType (Args...)> memoize(std::function<ReturnType (Args...)> func) {
  std::unordered_map<std::tuple<Args...>, ReturnType> cache;
  return ([=](Args... args) mutable {
          std::tuple<Args...> t(args...);
          if (cache.find(t) == cache.end())
             cache[t] = func(args...);
          return cache[t];
  });
}

template <stk::meta::IsArithmetic T>
constexpr auto fromBase(std::string_view x, stk::u8 base) noexcept -> T {
  auto&& out = T{};
  auto&& result =
      std::from_chars(stdr::cbegin(x), stdr::cend(x), out, base);
  stk::ensures(result.ec == std::errc{},
          std::format("cannot parse integer base {} from '{}': {}", base, x,
                      std::make_error_code(result.ec).message()));
  return out;
}

template <stdr::sized_range A, stdr::sized_range B>
constexpr auto cartesian_product(A&& a, B&& b) noexcept -> decltype(auto) {
  return std::forward<A>(a) 
    | stdv::transform([&b] (auto&& i) noexcept {
        return std::forward<B>(b)
          | stdv::transform([&i] (auto&& j) noexcept { return std::tuple{ i, j }; })
          | stdr::to<std::vector>();
    }) 
  | stdv::join
  | stdr::to<std::vector>();
}

template <stdr::sized_range A>
constexpr auto chunk(A&& a, stk::usize extent) noexcept -> decltype(auto) {
  return stdv::iota(0u, stdr::size(a))
    | stdv::stride(extent)
    | stdv::transform([&a, extent](auto i) noexcept {
        return stdr::subrange(
          stdr::begin(a) + i,
          stdr::begin(a) + i + extent
        );
    });
}

}
