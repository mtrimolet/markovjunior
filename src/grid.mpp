export module grid;

import std;
import stormkit.core;
import utils;
import geometry;

namespace stk  = stormkit;
namespace stdr = std::ranges;
namespace stdv = std::views;

export {

inline constexpr auto fromExtents(std::dims<3> extents) noexcept -> Area3::Size {
  return {
    extents.extent(2),
    extents.extent(1),
    extents.extent(0),
  };
}

inline constexpr auto toExtents(Area3::Size size) noexcept -> std::dims<3> {
  return std::dims<3>{
    size.z,
    size.y,
    size.x
  };
}

inline constexpr auto strides(std::dims<3> extents) noexcept -> std::dims<3> {
  return std::dims<3>{ extents.extent(2) * extents.extent(1), extents.extent(2), 1u };
}

inline constexpr auto toIndex(Area3::Offset u, std::dims<3> extents) noexcept -> stk::ioffset {
  return geometry::dot(u, static_cast<Area3::Offset>(fromExtents(strides(extents))));
}

inline constexpr auto fromIndex(stk::ioffset i, std::dims<3> extents) noexcept -> Area3::Offset {
  auto s = fromExtents(strides(extents));
  return Area3::Offset{i / s.x, i / s.y, i / s.z} % static_cast<Area3::Offset>(fromExtents(extents));
}

inline constexpr auto next(Area3::Offset u, std::dims<3> extents) noexcept -> Area3::Offset {
  return fromIndex(toIndex(u, extents) + 1, extents);
}

inline constexpr auto prev(Area3::Offset u, const std::dims<3>& extents) noexcept -> Area3::Offset {
  return fromIndex(toIndex(u, extents) - 1, extents);
}

inline constexpr auto mdiota(Area3 zone) noexcept -> decltype(auto) {
  return stdv::iota(stk::ioffset{ 0 }, static_cast<stk::ioffset>(zone.size.z * zone.size.y * zone.size.x))
    | stdv::transform(std::bind_back(fromIndex, toExtents(zone.size)))
    | stdv::transform(std::bind_back(std::plus<Area3::Offset>{}, zone.u));
}

// inline constexpr auto mdiota(Area3::Offset origin, Area3::Offset outerbound) noexcept -> decltype(auto) {
//   return mdiota<T>({origin, outerbound - origin});
// }

// inline constexpr auto mdiota(std::dims<3> extents) noexcept -> decltype(auto) {
//   return mdiota({}, fromExtents(extents));
// }

template <class T>
struct Grid {
  using Extents = std::dims<3>;

  Extents extents;
  std::vector<T> values;

  template<container_compatible_range<T> R>
  inline constexpr Grid(std::from_range_t, R&& _values, Extents _extents) noexcept 
  : extents{_extents}, values{std::from_range, _values}
  {}

  inline constexpr Grid(Extents _extents, T v) noexcept
  : Grid{std::from_range, stdv::repeat(v, _extents.extent(0) * _extents.extent(1) * _extents.extent(2)), _extents}
  {}

  inline constexpr Grid() noexcept
  : extents{}, values{}
  {}

  inline constexpr auto operator==(const Grid<T>& other) const noexcept -> bool = default;

  inline constexpr auto data() const noexcept -> decltype(auto) {
    return stdr::data(values);
  }
  inline constexpr auto cdata() const noexcept -> decltype(auto) {
    return stdr::cdata(values);
  }

  using View = std::mdspan<T, Extents>;
  inline constexpr operator View() const noexcept {
    return { data(), extents };
  }
  using ConstView = std::mdspan<const T, Extents>;
  inline constexpr operator ConstView() const noexcept {
    return { cdata(), extents };
  }

  inline constexpr T& operator[](Area3::Offset u) noexcept {
    return values[toIndex(u, extents)];
  }

  inline constexpr const T& operator[](Area3::Offset u) const noexcept {
    return values[toIndex(u, extents)];
  }

  inline constexpr T& at(Area3::Offset u) {
    return values.at(toIndex(u, extents));
  }

  inline constexpr const T& at(Area3::Offset u) const {
    return values.at(toIndex(u, extents));
  }

  inline constexpr auto begin() const noexcept -> decltype(auto) {
    return stdr::begin(values);
  }
  inline constexpr auto cbegin() const noexcept -> decltype(auto) {
    return stdr::cbegin(values);
  }

  inline constexpr auto end() const noexcept -> decltype(auto) {
    return stdr::end(values);
  }
  inline constexpr auto cend() const noexcept -> decltype(auto) {
    return stdr::cend(values);
  }

  inline constexpr auto empty() const noexcept -> decltype(auto) {
    return stdr::empty(values);
  }

  static inline constexpr auto parse(std::string_view str, std::function<T(char)> project = std::identity{}) noexcept -> decltype(auto) {
    static constexpr char ZSEP = ' ', YSEP = '/';

    auto&& values = str
      | stdv::split(ZSEP)
      | stdv::transform([&project](auto&& square){ 
          return square
            | stdv::split(YSEP)
            | stdv::transform([&project](auto&& line){
                return line
                  | stdv::transform(project)
                  | stdr::to<std::vector>();
              })
            | stdr::to<std::vector>(); 
        })
      | stdr::to<std::vector>();

    auto&& extents = std::dims<3>{
      stdr::size(values),
      stdr::empty(values) ? 0u
        : stdr::size(values[0]),
      stdr::empty(values) or stdr::empty(values[0]) ? 0u
        : stdr::size(values[0][0]),
    };

    return std::move(values)
      | stdv::join
      | stdv::join
      | stdr::to<Grid<T>>(std::move(extents));
  }

  inline constexpr auto area() const noexcept -> Area3 {
    return { {}, fromExtents(extents) };
  }

  inline constexpr auto xreflected() const noexcept -> Grid<T> {
    auto area = ::xreflected(this->area());
    return mdiota(area)
      | stdv::transform([this, size = area.size](auto&& u) noexcept {
          return this->at({ size.x - u.x - 1u, u.y, u.z });
      })
      // | stdv::transform(std::bind_front(&Grid<T>::at, this))
      | stdr::to<Grid<T>>(toExtents(area.size));
  }

  inline constexpr auto xyrotated() const noexcept -> Grid<T> {
    auto area = ::xyrotated(this->area());
    return mdiota(area)
      | stdv::transform([this, size = area.size](auto&& u) noexcept {
          return this->at({ u.y, size.x - u.x - 1u, u.z });
      })
      // | stdv::transform(std::bind_front(&Grid<T>::at, this))
      | stdr::to<Grid<T>>(toExtents(area.size));
  }

  inline constexpr auto zyrotated() const noexcept -> Grid<T> {
    auto area = ::zyrotated(this->area());
    return mdiota(area)
      | stdv::transform([this, size = area.size](auto&& u) noexcept {
          return this->at({ u.x, size.z - u.z - 1u, u.y });
      })
      // | stdv::transform(std::bind_front(&Grid<T>::at, this))
      | stdr::to<Grid<T>>(toExtents(area.size));
  }
};

template <class T>
struct std::formatter<Grid<T>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for Grid.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Grid<T>& g, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("{}", g.values);

      return stdr::copy(std::move(out).str(), ctx.out()).out;
  }
};

template <class T>
struct Change {
  Area3::Offset u;
  T value;
};

template <class T>
struct std::formatter<Change<T>> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for Grid.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Change<T>& c, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("change[u = {}, value = {}] ", c.u, c.value);

      return stdr::copy(std::move(out).str(), ctx.out()).out;
  }
};

template <class T>
struct TracedGrid : Grid<T> {
  std::vector<Change<T>> history;

  inline constexpr TracedGrid() noexcept
    : Grid<T>{}, history{} {}

  inline constexpr TracedGrid(Grid<T>::Extents _extents, T v) noexcept
    : Grid<T>{_extents, v}, history{} {}

  inline constexpr auto apply(Change<T> change) noexcept -> void {
    history.push_back(change);
    Grid<T>::operator[](change.u) = change.value;
  }
};
}
